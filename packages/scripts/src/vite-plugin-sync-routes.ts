import { readFileSync, writeFileSync, watch } from 'node:fs';
import { resolve } from 'node:path';

interface VitePlugin {
  name: string;
  buildStart?: () => void;
  configureServer?: (server: ViteDevServer) => void;
}

interface ViteDevServer {
  ws: {
    send: (payload: { type: string; path: string }) => void;
  };
  httpServer?: {
    on: (event: string, callback: () => void) => void;
  } | null;
}

export function syncRoutesToBackend(): VitePlugin {
  const routeTreePath = resolve(process.cwd(), 'src/routeTree.gen.ts');
  const outputPath = resolve(process.cwd(), '../../packages/backend/convex/reserved-routes.ts');

  function extractAndGenerateRoutes() {
    try {
      const content = readFileSync(routeTreePath, 'utf-8');

      // Extract all fullPath values from the route definitions
      const fullPathRegex = /fullPath:\s*'([^']+)'/g;
      const paths = new Set<string>();

      let match;
      while ((match = fullPathRegex.exec(content)) !== null) {
        const fullPath = match[1];
        if (!fullPath) continue;

        // Skip root path
        if (fullPath === '/') continue;

        // Extract first segment only (root-level routes)
        // Even from dynamic routes like /api/auth/$, we want to extract 'api'
        const firstSegment = fullPath.split('/').filter(Boolean)[0];

        // Only add if the first segment itself is not dynamic
        if (firstSegment && !firstSegment.includes('$')) {
          paths.add(firstSegment);
        }
      }

      // Generate TypeScript file
      const sortedPaths = Array.from(paths).sort();
      const pathsArray = sortedPaths.map(path => `  '${path}'`).join(',\n');
      const fileContent = `// This file is auto-generated by vite-plugin-sync-routes
// DO NOT EDIT MANUALLY - Changes will be overwritten

/**
 * Reserved route names from the frontend application.
 * These names should not be used for dynamic user-generated slugs.
 */
export const RESERVED_ROUTE_NAMES = [
${pathsArray},
] as const

/**
 * Check if a name is a reserved route name.
 * @param name - The name to check
 * @returns true if the name is reserved, false otherwise
 */
export function isReservedRouteName(name: string): boolean {
  return RESERVED_ROUTE_NAMES.includes(name as typeof RESERVED_ROUTE_NAMES[number])
}
`;

      writeFileSync(outputPath, fileContent, 'utf-8');
      console.log(`âœ“ Synced ${sortedPaths.length} route names to backend`);
    } catch (error) {
      console.error('Failed to sync routes:', error);
    }
  }

  return {
    name: 'sync-routes-to-backend',

    buildStart() {
      // Generate routes on build start
      extractAndGenerateRoutes();
    },

    configureServer(server) {
      // Watch the routeTree.gen.ts file for changes in dev mode
      const watcher = watch(routeTreePath, (eventType) => {
        if (eventType === 'change') {
          extractAndGenerateRoutes();

          // Trigger HMR to notify the dev server
          server.ws.send({
            type: 'full-reload',
            path: '*',
          });
        }
      });

      // Clean up watcher on server close
      server.httpServer?.on('close', () => {
        watcher.close();
      });
    },
  };
}
