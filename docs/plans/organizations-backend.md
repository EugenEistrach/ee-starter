# Organizations & Teams - Backend Implementation Plan

## Overview

Add Better Auth organization plugin to enable multi-tenancy with organization-scoped data, role-based access control, and member management.

## Key Requirements

- **Mandatory Organization**: Users must always belong to at least one organization
- **URL-based Active Org**: Organization slug is the root path (e.g., `/:slug/todos`)
- **Data Scoping**: All user data (todos, future features) scoped to organizations
- **Role-Based Access**: Use Better Auth default roles: `owner`, `admin`, `member`
- **Invitations**: Email-based invites (no expiry, but revocable)
- **Organization Switching**: Users can belong to multiple orgs, switch via URL
- **No Teams (Phase 1)**: Teams disabled for now to keep it simple
- **Reserved Routes**: Auto-synced from frontend routes (see PRFX-70)
- **Auto-generated Slugs**: Slugs generated from org name, collision-safe with random suffix

## Architecture Decision

Following project architecture:
- Thin Convex wrappers around Better Auth API methods
- Minimal helper functions (`ensureUserInOrganization`, `ensureUserRole`)
- Reserved routes auto-generated by Vite plugin (PRFX-70)
- Slug generation with collision handling
- Use `@workspace/utils/ensure` for flat error handling
- No custom schema - Better Auth handles all tables

## Better Auth API Methods Used

**Organization Operations:**
- `auth.api.organization.create({ name, slug })` - Create org
- `auth.api.organization.list()` - Get user's organizations
- `auth.api.organization.getFullOrganization({ organizationSlug })` - Get org by slug
- `auth.api.organization.checkSlug({ slug })` - Check slug availability

**Member Operations:**
- `auth.api.organization.getActiveMember()` - Get current membership
- `auth.api.organization.inviteMember({ email, role, organizationId })` - Send invite
- `auth.api.organization.listInvitations({ organizationId })` - Get pending invites
- `auth.api.organization.updateMemberRole({ memberId, role, organizationId })` - Change role
- `auth.api.organization.addMember()` - Direct add (server-only, for invitations)

**Note:** We do NOT use `setActive` - URL slug is single source of truth for active org.

## Implementation Steps

### 1. Update Better Auth Configuration

**File: `packages/backend/convex/auth.ts`**

Add organization plugin to `createAuth()`:
```typescript
import { organization } from 'better-auth/plugins'

plugins: [
  convex(),
  magicLink({...}),
  organization({
    teams: {
      enabled: false  // Disable teams for Phase 1
    },
    // Allow all users to create organizations (needed for onboarding)
    allowUserToCreateOrganization: async (user) => true,

    // Configure invitation emails
    async sendInvitationEmail(data) {
      const inviteLink = `${process.env.SITE_URL}/accept-invite/${data.id}`

      const template = createOrganizationInviteEmail({
        email: data.email,
        inviterName: data.inviter.user.name,
        organizationName: data.organization.name,
        inviteUrl: inviteLink,
        role: data.role,
      })

      await ctx.scheduler.runAfter(0, internal.emails.send, {
        to: data.email,
        template,
        metadata: { triggeredBy: 'organization-invite' },
      })
    },
  })
]
```

### 2. Regenerate Better Auth Schema

**Manual Process** (due to CLI bug):

```bash
cd packages/backend
npx @better-auth/cli generate -y --config convex/betterAuth/auth.ts
mv schema.ts convex/betterAuth/schema.ts
```

**Generated Tables:**
- `organization` - Organization metadata (name, slug, logo, metadata, createdAt, updatedAt)
- `member` - Organization members with roles (userId, organizationId, role, createdAt, updatedAt)
- `invitation` - Pending invitations (email, organizationId, role, invitedBy, status, expiresAt)

**Default Roles:**
- `owner` - Full control, can delete organization
- `admin` - Management permissions, can invite/remove members
- `member` - Basic member access

### 3. Create Organizations Helper Functions

**File: `packages/backend/shared/organizations.ts`**

```typescript
import type { QueryCtx, MutationCtx } from '../convex/_generated/server'
import { ensure } from '@workspace/utils'
import { isReservedRouteName } from '../convex/reservedRoutes' // Auto-generated by PRFX-70
import { authComponent } from '../convex/auth'

/**
 * Ensure user is a member of the organization
 */
export async function ensureUserInOrganization(
  ctx: QueryCtx,
  organizationId: string,
  userId: string
) {
  const member = await ctx.db
    .query('member')
    .withIndex('by_org_and_user', (q) =>
      q.eq('organizationId', organizationId).eq('userId', userId)
    )
    .first()

  ensure(member !== null, 'User is not a member of this organization')
  return member
}

/**
 * Ensure user has required role (or higher)
 * Role hierarchy: owner > admin > member
 */
export async function ensureUserRole(
  ctx: QueryCtx,
  organizationId: string,
  userId: string,
  requiredRole: 'owner' | 'admin' | 'member'
) {
  const member = await ensureUserInOrganization(ctx, organizationId, userId)

  const roleHierarchy: Record<string, number> = {
    owner: 3,
    admin: 2,
    member: 1,
  }

  const userRoleLevel = roleHierarchy[member.role] || 0
  const requiredRoleLevel = roleHierarchy[requiredRole] || 0

  ensure(
    userRoleLevel >= requiredRoleLevel,
    `${requiredRole} role or higher required`
  )

  return member
}

/**
 * Generate unique slug from organization name
 * Handles collisions with random suffix (no information leakage)
 */
export async function generateSlug(
  ctx: QueryCtx,
  name: string
): Promise<string> {
  // 1. Sanitize name to base slug
  let baseSlug = name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9-\s]/g, '') // Remove special chars
    .replace(/\s+/g, '-')         // Spaces to hyphens
    .replace(/-+/g, '-')          // Multiple hyphens to single
    .replace(/^-|-$/g, '')        // Trim hyphens from edges

  // 2. Ensure minimum length
  if (baseSlug.length < 2) {
    baseSlug = 'org' // Fallback for very short names
  }

  // 3. Truncate to max length (leave room for suffix)
  if (baseSlug.length > 45) {
    baseSlug = baseSlug.substring(0, 45).replace(/-$/, '')
  }

  // 4. Try base slug first (if not reserved/taken)
  if (!isReservedRouteName(baseSlug)) {
    const existing = await ctx.db
      .query('organization')
      .withIndex('by_slug', (q) => q.eq('slug', baseSlug))
      .first()

    if (!existing) {
      return baseSlug // Base slug is available!
    }
  }

  // 5. Append random suffix until unique
  const maxAttempts = 10
  for (let i = 0; i < maxAttempts; i++) {
    const suffix = generateRandomSuffix(4) // e.g., 'x7k2'
    const slug = `${baseSlug}-${suffix}`

    if (!isReservedRouteName(slug)) {
      const existing = await ctx.db
        .query('organization')
        .withIndex('by_slug', (q) => q.eq('slug', slug))
        .first()

      if (!existing) {
        return slug
      }
    }
  }

  // 6. Fallback: Use UUID fragment (should never reach here)
  const uuid = crypto.randomUUID().split('-')[0]
  return `${baseSlug}-${uuid}`
}

/**
 * Generate random alphanumeric suffix
 * Used for collision resolution without information leakage
 */
function generateRandomSuffix(length: number): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789'
  let result = ''
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return result
}

/**
 * Check if user has any organizations
 */
export async function userHasOrganizations(
  ctx: QueryCtx,
  userId: string
): Promise<boolean> {
  const membership = await ctx.db
    .query('member')
    .withIndex('by_user', (q) => q.eq('userId', userId))
    .first()

  return !!membership
}
```

### 4. Create Organization API Endpoints

**File: `packages/backend/convex/organizations.ts`**

Thin wrappers around Better Auth API:

```typescript
import { v } from 'convex/values'
import { mutation, query, action } from './_generated/server'
import { ensureUser, createAuth } from './auth'
import { ensure } from '@workspace/utils'
import * as orgHelpers from '../shared/organizations'

/**
 * Get user's organizations (for org switcher)
 */
export const listMyOrganizations = query({
  args: {},
  handler: async (ctx) => {
    const user = await ensureUser(ctx)

    const memberships = await ctx.db
      .query('member')
      .withIndex('by_user', (q) => q.eq('userId', user._id))
      .collect()

    const orgs = await Promise.all(
      memberships.map(async (m) => {
        const org = await ctx.db.get(m.organizationId)
        ensure(org !== null, 'Organization not found')
        return { ...org, role: m.role }
      })
    )

    return orgs
  },
})

/**
 * Get organization by slug (for URL routing)
 */
export const getBySlug = action({
  args: { slug: v.string() },
  handler: async (ctx, { slug }) => {
    const auth = createAuth(ctx)
    const org = await auth.api.organization.getFullOrganization({
      organizationSlug: slug,
    })

    ensure(org !== null, `Organization not found: ${slug}`)

    // Verify user is a member
    const user = await ensureUser(ctx)
    await orgHelpers.ensureUserInOrganization(ctx, org.id, user._id)

    return org
  },
})

/**
 * Check if user needs onboarding (has no organizations)
 */
export const needsOnboarding = query({
  args: {},
  handler: async (ctx) => {
    const user = await ensureUser(ctx)
    return !(await orgHelpers.userHasOrganizations(ctx, user._id))
  },
})

/**
 * Create organization with auto-generated slug
 */
export const create = action({
  args: {
    name: v.string(),
  },
  handler: async (ctx, { name }) => {
    const user = await ensureUser(ctx)

    // Auto-generate unique slug
    const slug = await orgHelpers.generateSlug(ctx, name)

    // Create via Better Auth API
    const auth = createAuth(ctx)
    const org = await auth.api.organization.create({
      name,
      slug,
    })

    return { organization: org, slug }
  },
})

/**
 * Get members and invitations for an organization
 */
export const getMembers = query({
  args: { organizationId: v.id('organization') },
  handler: async (ctx, { organizationId }) => {
    const user = await ensureUser(ctx)

    // Ensure user is a member
    await orgHelpers.ensureUserInOrganization(ctx, organizationId, user._id)

    // Get active members
    const members = await ctx.db
      .query('member')
      .withIndex('by_organization', (q) => q.eq('organizationId', organizationId))
      .collect()

    // Get pending invitations
    const invitations = await ctx.db
      .query('invitation')
      .withIndex('by_organization', (q) => q.eq('organizationId', organizationId))
      .collect()

    // Fetch user details for each member
    const membersWithUsers = await Promise.all(
      members.map(async (m) => {
        const userDoc = await ctx.db.get(m.userId)
        return {
          ...m,
          user: userDoc,
          status: 'active' as const,
        }
      })
    )

    // Format invitations
    const invitationsWithStatus = invitations.map(inv => ({
      ...inv,
      status: 'invited' as const,
    }))

    return {
      members: membersWithUsers,
      invitations: invitationsWithStatus,
    }
  },
})

/**
 * Invite member to organization
 */
export const inviteMember = action({
  args: {
    organizationId: v.id('organization'),
    email: v.string(),
    role: v.union(v.literal('owner'), v.literal('admin'), v.literal('member')),
  },
  handler: async (ctx, { organizationId, email, role }) => {
    const user = await ensureUser(ctx)

    // Ensure user is admin or owner
    await orgHelpers.ensureUserRole(ctx, organizationId, user._id, 'admin')

    // Use Better Auth API
    const auth = createAuth(ctx)
    await auth.api.organization.inviteMember({
      email,
      role,
      organizationId,
    })

    return { success: true }
  },
})

/**
 * Revoke invitation
 */
export const revokeInvitation = mutation({
  args: {
    invitationId: v.id('invitation'),
  },
  handler: async (ctx, { invitationId }) => {
    const user = await ensureUser(ctx)

    const invitation = await ctx.db.get(invitationId)
    ensure(invitation !== null, 'Invitation not found')

    // Ensure user is admin or owner
    await orgHelpers.ensureUserRole(ctx, invitation.organizationId, user._id, 'admin')

    // Delete invitation
    await ctx.db.delete(invitationId)

    return { success: true }
  },
})

/**
 * Remove member from organization
 */
export const removeMember = mutation({
  args: {
    organizationId: v.id('organization'),
    userId: v.id('user'),
  },
  handler: async (ctx, { organizationId, userId }) => {
    const currentUser = await ensureUser(ctx)

    // Ensure current user is admin or owner
    await orgHelpers.ensureUserRole(ctx, organizationId, currentUser._id, 'admin')

    // Can't remove yourself if you're the last owner/admin
    const admins = await ctx.db
      .query('member')
      .withIndex('by_organization', (q) => q.eq('organizationId', organizationId))
      .collect()
      .then(members => members.filter(m => m.role === 'owner' || m.role === 'admin'))

    ensure(
      !(admins.length === 1 && admins[0].userId === userId),
      'Cannot remove the last admin/owner'
    )

    // Remove membership
    const member = await ctx.db
      .query('member')
      .withIndex('by_org_and_user', (q) =>
        q.eq('organizationId', organizationId).eq('userId', userId)
      )
      .first()

    ensure(member !== null, 'Member not found')
    await ctx.db.delete(member._id)

    return { success: true }
  },
})

/**
 * Update member role
 */
export const updateMemberRole = action({
  args: {
    organizationId: v.id('organization'),
    memberId: v.id('member'),
    role: v.union(v.literal('owner'), v.literal('admin'), v.literal('member')),
  },
  handler: async (ctx, { organizationId, memberId, role }) => {
    const currentUser = await ensureUser(ctx)

    // Ensure current user is admin or owner
    await orgHelpers.ensureUserRole(ctx, organizationId, currentUser._id, 'admin')

    // Use Better Auth API
    const auth = createAuth(ctx)
    await auth.api.organization.updateMemberRole({
      memberId,
      role,
      organizationId,
    })

    return { success: true }
  },
})
```

### 5. Update Todos Feature for Organization Scoping

**File: `packages/backend/features/todos/schema.ts`**

Add `organizationId` field:
```typescript
export const todosSchema = {
  todos: defineTable({
    text: v.string(),
    completed: v.boolean(),
    organizationId: v.id('organization'),  // NEW: Scope to organization
    createdBy: v.id('user'),               // NEW: Track creator
  })
    .index('by_organization', ['organizationId'])
    .index('by_org_and_completed', ['organizationId', 'completed'])
}
```

**File: `packages/backend/features/todos/logic.ts`**

Update all functions to require `organizationId`:

```typescript
import { ensure } from '@workspace/utils'

export async function getAllTodos(
  ctx: QueryCtx,
  organizationId: string
) {
  return await ctx.db
    .query('todos')
    .withIndex('by_organization', (q) => q.eq('organizationId', organizationId))
    .collect()
}

export async function createTodo(
  ctx: MutationCtx,
  organizationId: string,
  userId: string,
  text: string
) {
  return await ctx.db.insert('todos', {
    text,
    completed: false,
    organizationId,
    createdBy: userId,
  })
}

export async function removeTodo(
  ctx: MutationCtx,
  id: Id<'todos'>
) {
  return await ctx.db.delete(id)
}

// Update other functions similarly...
```

**File: `packages/backend/convex/todos.ts`**

Add role-based permissions:

```typescript
import * as orgHelpers from '../shared/organizations'

export const getAll = query({
  args: {
    organizationId: v.id('organization')
  },
  handler: async (ctx, { organizationId }) => {
    const user = await ensureUser(ctx)

    // Verify user is member
    await orgHelpers.ensureUserInOrganization(ctx, organizationId, user._id)

    return await todosLogic.getAllTodos(ctx, organizationId)
  },
})

export const create = mutation({
  args: {
    organizationId: v.id('organization'),
    text: v.string(),
  },
  handler: async (ctx, { organizationId, text }) => {
    const user = await ensureUser(ctx)

    // Verify user is member
    await orgHelpers.ensureUserInOrganization(ctx, organizationId, user._id)

    return await todosLogic.createTodo(ctx, organizationId, user._id, text)
  },
})

export const remove = mutation({
  args: {
    id: v.id('todos'),
    organizationId: v.id('organization'),
  },
  handler: async (ctx, { id, organizationId }) => {
    const user = await ensureUser(ctx)

    // Only owner/admin can delete todos
    await orgHelpers.ensureUserRole(ctx, organizationId, user._id, 'admin')

    return await todosLogic.removeTodo(ctx, id)
  },
})
```

### 6. Email Template for Invitations

**File: `packages/backend/features/email/templates/organization-invite.ts`**

```typescript
import type { EmailTemplate } from '../types'

interface OrganizationInviteData {
  email: string
  inviterName: string
  organizationName: string
  inviteUrl: string
  role: string
}

export function createOrganizationInviteEmail(
  data: OrganizationInviteData
): EmailTemplate {
  return {
    subject: `You've been invited to ${data.organizationName}`,
    html: `
      <!DOCTYPE html>
      <html>
        <body>
          <h1>You're invited!</h1>
          <p><strong>${data.inviterName}</strong> has invited you to join <strong>${data.organizationName}</strong> as a ${data.role}.</p>
          <a href="${data.inviteUrl}">Accept Invitation</a>
        </body>
      </html>
    `,
    text: `
      You're invited!

      ${data.inviterName} has invited you to join ${data.organizationName} as a ${data.role}.

      Accept invitation: ${data.inviteUrl}
    `,
  }
}
```

## Reserved Routes (Auto-generated)

Reserved route names are automatically synced from frontend routes via Vite plugin (PRFX-70).

**File: `packages/backend/convex/reservedRoutes.ts` (Auto-generated)**

```typescript
// Auto-generated by vite-plugin-sync-reserved-routes
// Do not edit manually

export const RESERVED_ROUTE_NAMES = [
  'api',
  'login',
  'signup',
  'reset-password',
  'forgot-password',
  'onboarding',
  'accept-invite',
] as const

export function isReservedRouteName(name: string): boolean {
  return (RESERVED_ROUTE_NAMES as readonly string[]).includes(name)
}
```

This file updates automatically when routes change - no manual maintenance required.

## Testing Checklist

- [ ] Schema regeneration successful
- [ ] Organization creation with auto-generated slug works
- [ ] Slug collision handling (appends random suffix)
- [ ] Reserved route names prevent org creation
- [ ] User can belong to multiple organizations
- [ ] Invitations sent and accepted
- [ ] Role permissions enforced (owner > admin > member)
- [ ] Todos scoped to organizations
- [ ] Only owner/admin can delete todos
- [ ] Organization switching via URL works
- [ ] Onboarding flow for new users
- [ ] Cannot remove last owner/admin
- [ ] Invitation revocation works
- [ ] `ensure()` utility used consistently

## Known Issues & Workarounds

1. **Better Auth CLI Bug**: Schema outputs to wrong directory
   - **Workaround**: Manual `mv` command after generation

2. **@convex-dev/better-auth Type Issues**: Some `@ts-expect-error` needed
   - **Workaround**: Use type assertions where needed

3. **Reserved Routes Sync**: Requires PRFX-70 implementation
   - **Temporary**: Manual list until Vite plugin is implemented

## Dependencies

- **PRFX-70**: Vite plugin to auto-sync reserved route names
- Better Auth organization plugin
- Convex Better Auth adapter

## Future Enhancements (Not in Phase 1)

- Teams within organizations
- Dynamic access control (custom permissions beyond owner/admin/member)
- Organization settings (rename, logo upload, delete)
- Organization transfer/ownership change
- Audit logs for organization actions
- Public invite links
